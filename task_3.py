"""
На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.
Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).
Объяснить, почему вы считаете, что функция соответствует заданным критериям.
"""
import random
from typing import List


def qustom_sort(a: List[int], l: int, r: int) -> None:
    if r > l:
        q = select_pivot(a, l, r)
        qustom_sort(a, l, q)
        qustom_sort(a, q + 1, r)


def select_pivot(a: List[int], l: int, r: int):
    pivot = a[(l + r) // 2]
    i, j = l, r
    while True:
        while a[i] < pivot:
            i += 1
        while a[j] > pivot:
            j -= 1
        if i >= j:
            return j
        a[i], a[j] = a[j], a[i]


"""
Функция сортирующая массив элементов A:
Sort(A,p,r)
1 if p < r
2    then           q := round_half_down((p+r)/2)
3                       Sort(A,p,q)
4                       Sort(A,q+1,r)
5                       Merge(A,p,q,r)

Пример массива:
A = (5,2,4,6,1,3,2,6)
"""


def sort(a: list, p, r: int) -> None:
    if p < r:
        q = (p + r) // 2
        sort(a, p, q)
        sort(a, q + 1, r)
        merge(a, p, q, r)


def merge(a: list, p, q, r: int) -> None:
    buf = [-1 for i in range(0, r - p + 1)]
    i, j = p, q + 1

    for k in range(0, r - p + 1):
        if i > q:
            buf[k] = a[j]
            j += 1
            continue

        if j > r:
            buf[k] = a[i]
            i += 1
            continue

        if a[i] < a[j]:
            buf[k] = a[i]
            i += 1
        else:
            buf[k] = a[j]
            j += 1

    for k in range(0, len(buf)):
        a[p + k] = buf[k]


if __name__ == "__main__":
    a = [random.randint(0, 100) for _ in range(0, 10)]
    print(a)
    sort(a, 0, len(a) - 1)
    print(a)

"""
Выше представлен один из возможных алгоритмов сортировки. Это один из вариантов сортировки слиянием.
Из задания следует, что моя задача - написать самую быструю сортировку из существующих и объяснить, чем она отличается 
от остальных придуманных человечеством алгоритмов сортировки.
Это не единственный кандидат на решение предложенной задачи. Я также рассматривал вариант быстрой сортировки, но он
неустойчив: при "неудачных" входных данных его сложность может возрасти до O(n^2). 
Предоложенный же мной алгоритм имеет устойчивую сложность O(n log n).
Можно ли ещё быстрее? Думаю, да. Изобретательный потенциал человечества неисчерпаем. Вряд ли в серьёзных библиотеках для 
операций с данными используется именно предложенный мной алгоритм. Полагаю, там применён более сложный подход с 
включением математических "фокусов" и эвристик. 
"""